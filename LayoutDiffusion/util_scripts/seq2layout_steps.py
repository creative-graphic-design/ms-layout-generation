# this file is to convert generated seq format data to layout data
# input: pred data in seq format, generated by Diffusion-LM decoder
# output: pred data in layout format (lrtb), used for drawing to pics

from __future__ import annotations

import os
import pickle
import sys
from typing import Iterable, List

import torch


DEFAULT_FIRST_PATH = (
    "../results/generation_outputs/bst_bbox_no_absorb_sep5/noise_22/samples_elem1.json"
)


def decapulate(bbox: torch.Tensor):
    if len(bbox.size()) == 2:
        x1, y1, x2, y2 = bbox.T
    else:
        x1, y1, x2, y2 = bbox.permute(2, 0, 1)
    return x1, y1, x2, y2


def convert_ltwh_to_ltrb(bbox: torch.Tensor) -> torch.Tensor:
    left, top, width, height = decapulate(bbox)
    right = left + width
    bottom = top + height
    return torch.stack([left, top, right, bottom], dim=-1)


def continuize(bbox, first_path: str) -> torch.Tensor:
    """
    Args:
        discrete_bbox torch.LongTensor: N * 4

    Returns:
        continuous_bbox torch.Tensor: N * 4
    """
    bbox = torch.tensor(bbox).long()
    if "ltrb" in first_path or "bst" in first_path:
        x1, y1, x2, y2 = decapulate(bbox)
    else:
        x1, y1, x2, y2 = decapulate(convert_ltwh_to_ltrb(bbox))
    cx1, cx2 = x1 / 127, x2 / 127
    cy1, cy2 = y1 / 127, y2 / 127
    return torch.stack([cx1, cy1, cx2, cy2], dim=-1).float()


def _clean_lines(lines: Iterable[str]) -> List[List[str]]:
    cleaned = []
    for line in lines:
        words = line.split(" ")
        words_new = [word.strip('["').replace('"]', "").strip() for word in words]
        if words_new and words_new[-1] == "":
            words_new.pop()
        cleaned.append(words_new)
    return cleaned


def _extract_layouts(lines: List[List[str]]) -> List[List[str]]:
    layouts = []
    for line in lines:
        sos = 999
        eos = 0
        tmp = 0
        for i, word in enumerate(line):
            if word == "START":
                sos = i
            elif word == "END":
                eos = i
            elif word == "|":
                tmp = i
                if sos == 999:
                    sos = i
        if eos == 0 or eos < sos:
            eos = tmp
        if sos < eos:
            layouts.append(line[sos + 1 : eos])
    return layouts


def _split_layouts(layouts: List[List[str]]) -> List[List[List[str]]]:
    layouts_sep = []
    for list1 in layouts:
        if "|" not in list1:
            layouts_sep.append([list1[0:5]])
            continue
        index_list = [idx for idx, item in enumerate(list1) if item == "|"]
        index_list = [0] + index_list

        head = list1[0 : index_list[1]]
        tail = list1[index_list[len(index_list) - 1] :]
        if tail:
            tail.pop(0)
        c = len(index_list)
        collected = []
        for i in range(1, c - 1):
            small_list = list1[index_list[i] : index_list[i + 1]]
            if small_list:
                small_list.pop(0)
            if small_list:
                collected.append(small_list)
        collected.insert(0, head)
        collected.append(tail)
        layouts_sep.append(collected)
    return layouts_sep


def _build_layout_outputs(layouts_sep: List[List[List[str]]], first_path: str):
    labels_rico = [
        "Text",
        "Image",
        "Icon",
        "List_Item",
        "Text_Button",
        "Toolbar",
        "Web_View",
        "Input",
        "Card",
        "Advertisement",
        "Background_Image",
        "Drawer",
        "Radio_Button",
        "Checkbox",
        "Multi_Tab",
        "Pager_Indicator",
        "Modal",
        "On_Off_Switch",
        "Slider",
        "Map_View",
        "Button_Bar",
        "Video",
        "Bottom_Navigation",
        "Number_Stepper",
        "Date_Picker",
    ]
    layouts_final = []
    for layout in layouts_sep:
        layout_final = {"pred": []}
        bboxs = []
        labels = []
        bboxs_continue = []
        for element in layout:
            if not element:
                continue
            if len(element) >= 4 and all(str.isdigit(item) for item in element[-4:]):
                bboxs.append([int(num) for num in element[-4:]])
            else:
                continue
            bboxs_continue = continuize(bboxs, first_path)

            if len(element) > 1 and str.isdigit(element[1]):
                if element[0] in labels_rico:
                    labels.append(labels_rico.index(element[0]) + 1)
                else:
                    continue
        if len(bboxs_continue) < len(labels):
            labels = labels[: len(bboxs_continue)]
        if len(bboxs_continue) > len(labels):
            bboxs_continue = bboxs_continue[: len(labels)]
        layout_final["pred"].append(bboxs_continue)
        layout_final["pred"].append(labels)
        layouts_final.append(layout_final)
    return layouts_final


def _prefix_from_first_path(first_path: str) -> str:
    return "_".join(first_path.split("_")[0:-1])


def generate_layouts(first_path: str, max_elems: int = 50) -> List[str]:
    output_paths = []
    prefix = _prefix_from_first_path(first_path)
    for iidx in range(max_elems):
        json_path = f"{prefix}_elem{iidx + 1}.json"
        with open(json_path, "r") as f:
            lines = f.readlines()

        cleaned = _clean_lines(lines)
        layouts = _extract_layouts(cleaned)
        layouts_sep = _split_layouts(layouts)
        layouts_final = _build_layout_outputs(layouts_sep, first_path)

        out_path = f"{prefix}_elem{iidx + 1}.pt"
        with open(out_path, "wb") as f:
            pickle.dump(layouts_final, f)
        output_paths.append(out_path)
    return output_paths


def draw_outputs(first_path: str, max_elems: int = 50, sample_count: int = 100):
    prefix = _prefix_from_first_path(first_path)
    base_dir = "/".join(first_path.split("/")[0:-1])
    for iidx in range(max_elems):
        pt_path = f"{prefix}_elem{iidx + 1}.pt"
        out_dir = f"{base_dir}/sample_out{iidx + 1}"
        cmd = (
            "python eval_src/tools/draw_from_results.py -d rico "
            f"-p {pt_path} -s {out_dir} -n {sample_count}"
        )
        os.system(cmd)


def main(argv: list[str] | None = None) -> int:
    argv = list(sys.argv[1:] if argv is None else argv)
    first_path = argv[0] if argv else DEFAULT_FIRST_PATH
    max_elems = int(argv[1]) if len(argv) > 1 else 50
    generate_layouts(first_path, max_elems=max_elems)
    draw_outputs(first_path, max_elems=max_elems)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
